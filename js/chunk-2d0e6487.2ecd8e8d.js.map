{"version":3,"sources":["webpack:///./node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_3.entry.js"],"names":["__webpack_require__","r","__webpack_exports__","d","AmplifyRadioButton","AmplifyToast","AmplifyTOTPSetup","_index_83f2275b_js__WEBPACK_IMPORTED_MODULE_0__","_aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__","_aws_amplify_core__WEBPACK_IMPORTED_MODULE_2__","_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_3__","_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_4__","_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_5__","_constants_d7afd96c_js__WEBPACK_IMPORTED_MODULE_6__","_helpers_80b400b1_js__WEBPACK_IMPORTED_MODULE_7__","_auth_helpers_aad95737_js__WEBPACK_IMPORTED_MODULE_8__","buffer__WEBPACK_IMPORTED_MODULE_9__","buffer__WEBPACK_IMPORTED_MODULE_9___default","n","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","v","op","TypeError","call","pop","length","push","amplifyRadioButtonCss","hostRef","Object","placeholder","checked","disabled","prototype","render","class","assign","type","name","onInput","handleInputChange","id","fieldId","inputProps","htmlFor","style","amplifyToastCss","message","onClick","handleClose","canPromise","toString","isarray","Array","isArray","arr","typedArraySupport","Uint8Array","__proto__","foo","Buffer","TYPED_ARRAY_SUPPORT","K_MAX_LENGTH","arg","offset","allocUnsafe","from","RangeError","isnan","val","createBuffer","that","buf","size","i","fromString","string","byteLength","actual","write","slice","fromArrayLike","array","fromArrayBuffer","byteOffset","undefined","fromObject","obj","isBuffer","len","copy","ArrayBuffer","buffer","data","utf8ToBytes","units","codePoint","Infinity","leadSurrogate","bytes","charCodeAt","Error","isView","blitBuffer","src","dst","utf8Write","species","defineProperty","configurable","enumerable","writable","isFinite","remaining","start","end","newBuf","subarray","sliceLen","target","targetStart","set","fill","code","concat","list","pos","_isBuffer","b","toSJISFunction","alloc","from_1","typedarrayBuffer","CODEWORDS_COUNT","getSymbolSize","version","getSymbolTotalCodewords","getBCHDigit","digit","setToSJISFunction","isKanjiModeEnabled","toSJIS","kanji","utils","createCommonjsModule","fn","basedir","module","path","exports","require","base","commonjsRequire","errorCorrectionLevel","lcStr","toLowerCase","L","M","Q","H","bit","isValid","level","defaultValue","BitBuffer","get","index","bufIndex","Math","floor","put","num","putBit","getLengthInBits","bitBuffer","BitMatrix","reservedBit","row","col","reserved","xor","isReserved","bitMatrix","alignmentPattern","getRowColCoords","posCount","intervals","ceil","positions","reverse","getPositions","coords","posLength","j","getSymbolSize$1","FINDER_PATTERN_SIZE","finderPattern","maskPattern","Patterns","PATTERN000","PATTERN001","PATTERN010","PATTERN011","PATTERN100","PATTERN101","PATTERN110","PATTERN111","PenaltyScores","N1","N2","N3","N4","getMaskAt","mask","isNaN","parseInt","getPenaltyN1","points","sameCountCol","sameCountRow","lastCol","lastRow","getPenaltyN2","last","getPenaltyN3","bitsCol","bitsRow","getPenaltyN4","darkCount","modulesCount","k","abs","applyMask","pattern","getBestMask","setupFormatFunc","numPatterns","keys","bestPattern","lowerPenalty","p","penalty","EC_BLOCKS_TABLE","EC_CODEWORDS_TABLE","getBlocksCount","errorCorrectionLevel$1","getTotalCodewordsCount","errorCorrectionCode","EXP_TABLE","LOG_TABLE","x","log","exp","mul","galoisField","polynomial","p1","p2","coeff","mod","divident","divisor","generateECPolynomial","degree","poly","Buffer$1","a","ReedSolomonEncoder","genPoly","initialize","encode","pad","paddedData","remainder","buff","reedSolomonEncoder","versionCheck","numeric","alphanumeric","replace","byte","KANJI","RegExp","BYTE_KANJI","BYTE","NUMERIC","ALPHANUMERIC","TEST_KANJI","TEST_NUMERIC","TEST_ALPHANUMERIC","testKanji","str","test","testNumeric","testAlphanumeric","regex","mode","ccBits","MIXED","getCharCountIndicator","getBestModeForData","dataStr","G18","G18_BCH","getBestVersionForDataLength","currentVersion","getCapacity","getReservedBitsCount","mode$1","getTotalBitsFromDataArray","segments","totalBits","forEach","reservedBits","getBitsLength","getBestVersionForMixedData","totalCodewords","ecTotalCodewords","dataTotalCodewordsBits","usableBits","getBestVersionForData","seg","ecl","getLength","getEncodedBits","G15","G15_MASK","G15_BCH","formatInfo","NumericData","group","substr","remainingNum","numericData","ALPHA_NUM_CHARS","AlphanumericData","indexOf","alphanumericData","ByteData","l","byteData","KanjiData","kanjiData","dijkstra_1","dijkstra","single_source_shortest_paths","graph","s","predecessors","costs","closest","u","cost_of_s_to_u","adjacent_nodes","cost_of_e","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","first_visit","open","PriorityQueue","make","empty","cost","hasOwnProperty","msg","join","extract_shortest_path_from_predecessor_list","nodes","find_path","opts","key","T","queue","sorter","default_sorter","item","sort","shift","getStringByteLength","unescape","encodeURIComponent","getSegments","exec","getSegmentsFromString","byteSegs","kanjiSegs","numSegs","alphaNumSegs","segs","s1","s2","map","getSegmentBitsLength","mergeSegments","reduce","acc","curr","prevSeg","buildNodes","buildGraph","table","prevNodeIds","nodeGroup","currentNodeIds","node","lastCount","prevNodeId","buildSingleSegment","modesHint","bestMode","fromArray","optimizedSegs","rawSplit","setupFinderPattern","matrix","c","setupTimingPattern","setupAlignmentPattern","setupVersionInfo","version$1","bits","setupFormatInfo","setupData","inc","bitIndex","byteIndex","dark","createData","remainingByte","createCodewords","dataTotalCodewords","ecTotalBlocks","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","dcData","ecData","maxDataSize","dataSize","max","createSymbol","maskPattern$1","segments$1","estimatedVersion","rawSegments","bestVersion","dataBits","moduleCount","modules","bind","create","options","toSJISFunc","qrcode","utils$1","hex2rgba","hex","hexCode","split","hexValue","getOptions","color","margin","width","scale","light","rendererOpts","getScale","qrSize","getImageWidth","qrToImageData","imgData","qr","symbolSize","scaledMargin","palette","posDst","pxColor","iSrc","jSrc","canvas","clearCanvas","ctx","clearRect","height","getCanvasElement","document","createElement","qrData","canvasEl","getContext","image","createImageData","putImageData","renderToDataURL","toDataURL","quality","getColorAttrib","attrib","alpha","toFixed","svgCmd","cmd","qrToPath","moveBy","newRow","lineLength","cb","qrcodesize","bg","viewBox","svgTag","renderCanvas","renderFunc","text","args","arguments","argsNum","isLastArgCb","create$1","toCanvas","toString_1","browser","amplifyTotpSetupCss","logger","class_1","autoFocus","handleAuthStateChange","headerText","TOTP_HEADER_TEXT","issuer","TOTP_ISSUER","setupMessage","qrCodeInput","loading","componentWillLoad","_this","_a","removeHubListener","authState","TOTPSetup","setup","disconnectedCallback","buildOtpAuthPath","user","secretKey","username","onTOTPEvent","event","debug","handleTotpInputChange","generateQRCode","codeFromTotp","error_1","_b","qrCodeImageSource","encodedIssuer","error_2","challengeName","encodeURI","setupTOTP","TOTP_SETUP_FAILURE","verifyTotpToken","error_3","preventDefault","setPreferredMFA","TOTP","TOTP_SUCCESS_MESSAGE","error","submitButtonText","TOTP_SUBMIT_BUTTON_TEXT","handleSubmit","alt","QR_CODE_ALT","TOTP_LABEL"],"mappings":"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","file":"js/chunk-2d0e6487.2ecd8e8d.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { r as registerInstance, h, H as Host } from './index-83f2275b.js';\nimport { Logger, I18n } from '@aws-amplify/core';\nimport { M as MfaOption, A as AuthState } from './auth-types-78df304e.js';\nimport { Auth } from '@aws-amplify/auth';\nimport { T as Translations } from './Translations-c833f663.js';\nimport { S as SETUP_TOTP, i as SUCCESS, N as NO_AUTH_MODULE_FOUND } from './constants-d7afd96c.js';\nimport { d as dispatchAuthStateChangeEvent, o as onAuthUIStateChange, a as dispatchToastHubEvent } from './helpers-80b400b1.js';\nimport { c as checkContact } from './auth-helpers-aad95737.js';\nimport buffer from 'buffer';\nvar amplifyRadioButtonCss = \":host{--font-family:var(--amplify-font-family)}.radio-button{display:block;width:100%;padding:16px;font-size:var(--amplify-text-sm);font-family:var(--font-family)}.radio-button input{margin-right:12px}\";\nvar AmplifyRadioButton = /** @class */ (function () {\n    function AmplifyRadioButton(hostRef) {\n        registerInstance(this, hostRef);\n        /** (Optional) The placeholder for the input element.  Using hints is recommended, but placeholders can also be useful to convey information to users. */\n        this.placeholder = '';\n        /** If `true`, the radio button is selected. */\n        this.checked = false;\n        /** If `true`, the checkbox is disabled */\n        this.disabled = false;\n    }\n    AmplifyRadioButton.prototype.render = function () {\n        return (h(\"span\", { class: \"radio-button\" }, h(\"input\", Object.assign({ type: \"radio\", name: this.name, value: this.value, onInput: this.handleInputChange, placeholder: this.placeholder, id: this.fieldId, checked: this.checked, disabled: this.disabled }, this.inputProps)), h(\"amplify-label\", { htmlFor: this.fieldId }, this.label)));\n    };\n    return AmplifyRadioButton;\n}());\nAmplifyRadioButton.style = amplifyRadioButtonCss;\nvar amplifyToastCss = \":host{--background-color:var(--amplify-secondary-tint);--color:var(--amplify-white);--font-size:var(--amplify-text-sm);--font-family:var(--amplify-font-family);--close-icon-color:var(--amplify-white);--close-icon-hover:var(--amplify-red)}.toast-icon{padding-right:5px}.toast{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;position:absolute;top:0;left:0;width:100%;z-index:99;-webkit-box-shadow:0 0 5px 0 rgba(0, 0, 0, 0.3);box-shadow:0 0 5px 0 rgba(0, 0, 0, 0.3);padding:16px;background-color:var(--background-color);font-size:var(--font-size);color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:5px;font-family:var(--font-family)}.toast>span{margin-right:10px}.toast-close{margin-left:auto;-ms-flex-item-align:center;align-self:center;position:relative;width:18px;height:18px;overflow:hidden;cursor:pointer;background:transparent;border:none}.toast-close::before,.toast-close::after{content:\\\"\\\";position:absolute;height:2px;width:100%;top:50%;left:0;margin-top:-1px;background:var(--close-icon-color)}.toast-close:hover::before,.toast-close:hover::after{background:var(--close-icon-hover)}.toast-close::before{-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);-o-transform:rotate(45deg);transform:rotate(45deg)}.toast-close::after{-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);-o-transform:rotate(-45deg);transform:rotate(-45deg)}\";\nvar AmplifyToast = /** @class */ (function () {\n    function AmplifyToast(hostRef) {\n        registerInstance(this, hostRef);\n        /** Message to be displayed inside the toast*/\n        this.message = '';\n    }\n    /*\n  TODO #170365145: Work on a helper function that will populate and\n  update class colors for success / warning / failure messages\n  */\n    AmplifyToast.prototype.render = function () {\n        return (h(\"div\", { class: \"toast\" }, h(\"amplify-icon\", { class: \"toast-icon\", name: \"warning\" }), this.message ? h(\"span\", null, this.message) : null, h(\"slot\", null), h(\"button\", { class: \"toast-close\", onClick: this.handleClose })));\n    };\n    return AmplifyToast;\n}());\nAmplifyToast.style = amplifyToastCss;\n// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\nvar canPromise = function () {\n    return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n};\nvar toString = {}.toString;\nvar isarray = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n};\nfunction typedArraySupport() {\n    // Can typed array instances be augmented?\n    try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };\n        return arr.foo() === 42;\n    }\n    catch (e) {\n        return false;\n    }\n}\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nvar K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff;\nfunction Buffer(arg, offset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, offset, length);\n    }\n    if (typeof arg === 'number') {\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, offset, length);\n}\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) {\n        Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true,\n            enumerable: false,\n            writable: false\n        });\n    }\n}\nfunction checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n    }\n    return length | 0;\n}\nfunction isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n}\nfunction createBuffer(that, length) {\n    var buf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        buf = new Uint8Array(length);\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = that;\n        if (buf === null) {\n            buf = new Buffer(length);\n        }\n        buf.length = length;\n    }\n    return buf;\n}\nfunction allocUnsafe(that, size) {\n    var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            buf[i] = 0;\n        }\n    }\n    return buf;\n}\nfunction fromString(that, string) {\n    var length = byteLength(string) | 0;\n    var buf = createBuffer(that, length);\n    var actual = buf.write(string);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n    }\n    var buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    }\n    else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = fromArrayLike(that, buf);\n    }\n    return buf;\n}\nfunction fromObject(that, obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        var buf = createBuffer(that, len);\n        if (buf.length === 0) {\n            return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj) {\n        if ((typeof ArrayBuffer !== 'undefined' &&\n            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction byteLength(string) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        string = '' + string;\n    }\n    var len = string.length;\n    if (len === 0)\n        return 0;\n    return utf8ToBytes(string).length;\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length))\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction from(that, value, offset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, offset, length);\n    }\n    if (typeof value === 'string') {\n        return fromString(that, value);\n    }\n    return fromObject(that, value);\n}\nBuffer.prototype.write = function write(string, offset, length) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, encoding)\n    }\n    else if (length === undefined && typeof offset === 'string') {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, offset[, length])\n    }\n    else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n        }\n        else {\n            length = undefined;\n        }\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n        length = remaining;\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n    }\n    return utf8Write(this, string, offset, length);\n};\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0)\n            start = 0;\n    }\n    else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0)\n            end = 0;\n    }\n    else if (end > len) {\n        end = len;\n    }\n    if (end < start)\n        end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        newBuf.__proto__ = Buffer.prototype;\n    }\n    else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start)\n        start = 0;\n    if (!end && end !== 0)\n        end = this.length;\n    if (targetStart >= target.length)\n        targetStart = target.length;\n    if (!targetStart)\n        targetStart = 0;\n    if (end > 0 && end < start)\n        end = start;\n    // Copy 0 bytes; we're done\n    if (end === start)\n        return 0;\n    if (target.length === 0 || this.length === 0)\n        return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds');\n    if (end < 0)\n        throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length)\n        end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\nBuffer.prototype.fill = function fill(val, start, end) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            start = 0;\n            end = this.length;\n        }\n        else if (typeof end === 'string') {\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n    }\n    else if (typeof val === 'number') {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val)\n        val = 0;\n    var i;\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val;\n        }\n    }\n    else {\n        var bytes = Buffer.isBuffer(val)\n            ? val\n            : new Buffer(val);\n        var len = bytes.length;\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\nBuffer.concat = function concat(list, length) {\n    if (!isarray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return createBuffer(null, 0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n        }\n    }\n    var buffer = allocUnsafe(null, length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nBuffer.byteLength = byteLength;\nBuffer.prototype._isBuffer = true;\nBuffer.isBuffer = function isBuffer(b) {\n    return !!(b != null && b._isBuffer);\n};\nvar alloc = function (size) {\n    var buffer = new Buffer(size);\n    buffer.fill(0);\n    return buffer;\n};\nvar from_1 = function (data) {\n    return new Buffer(data);\n};\nvar typedarrayBuffer = {\n    alloc: alloc,\n    from: from_1\n};\nvar toSJISFunction;\nvar CODEWORDS_COUNT = [\n    0,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n];\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nvar getSymbolSize = function getSymbolSize(version) {\n    if (!version)\n        throw new Error('\"version\" cannot be null or undefined');\n    if (version < 1 || version > 40)\n        throw new Error('\"version\" should be in range from 1 to 40');\n    return version * 4 + 17;\n};\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nvar getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n    return CODEWORDS_COUNT[version];\n};\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nvar getBCHDigit = function (data) {\n    var digit = 0;\n    while (data !== 0) {\n        digit++;\n        data >>>= 1;\n    }\n    return digit;\n};\nvar setToSJISFunction = function setToSJISFunction(f) {\n    if (typeof f !== 'function') {\n        throw new Error('\"toSJISFunc\" is not a valid function.');\n    }\n    toSJISFunction = f;\n};\nvar isKanjiModeEnabled = function () {\n    return typeof toSJISFunction !== 'undefined';\n};\nvar toSJIS = function toSJIS(kanji) {\n    return toSJISFunction(kanji);\n};\nvar utils = {\n    getSymbolSize: getSymbolSize,\n    getSymbolTotalCodewords: getSymbolTotalCodewords,\n    getBCHDigit: getBCHDigit,\n    setToSJISFunction: setToSJISFunction,\n    isKanjiModeEnabled: isKanjiModeEnabled,\n    toSJIS: toSJIS\n};\nfunction createCommonjsModule(fn, basedir, module) {\n    return module = {\n        path: basedir,\n        exports: {},\n        require: function (path, base) {\n            return commonjsRequire();\n        }\n    }, fn(module, module.exports), module.exports;\n}\nfunction commonjsRequire() {\n    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\nvar errorCorrectionLevel = createCommonjsModule(function (module, exports) {\n    exports.L = { bit: 1 };\n    exports.M = { bit: 0 };\n    exports.Q = { bit: 3 };\n    exports.H = { bit: 2 };\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'l':\n            case 'low':\n                return exports.L;\n            case 'm':\n            case 'medium':\n                return exports.M;\n            case 'q':\n            case 'quartile':\n                return exports.Q;\n            case 'h':\n            case 'high':\n                return exports.H;\n            default:\n                throw new Error('Unknown EC Level: ' + string);\n        }\n    }\n    exports.isValid = function isValid(level) {\n        return level && typeof level.bit !== 'undefined' &&\n            level.bit >= 0 && level.bit < 4;\n    };\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nfunction BitBuffer() {\n    this.buffer = [];\n    this.length = 0;\n}\nBitBuffer.prototype = {\n    get: function (index) {\n        var bufIndex = Math.floor(index / 8);\n        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;\n    },\n    put: function (num, length) {\n        for (var i = 0; i < length; i++) {\n            this.putBit(((num >>> (length - i - 1)) & 1) === 1);\n        }\n    },\n    getLengthInBits: function () {\n        return this.length;\n    },\n    putBit: function (bit) {\n        var bufIndex = Math.floor(this.length / 8);\n        if (this.buffer.length <= bufIndex) {\n            this.buffer.push(0);\n        }\n        if (bit) {\n            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));\n        }\n        this.length++;\n    }\n};\nvar bitBuffer = BitBuffer;\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix(size) {\n    if (!size || size < 1) {\n        throw new Error('BitMatrix size must be defined and greater than 0');\n    }\n    this.size = size;\n    this.data = typedarrayBuffer.alloc(size * size);\n    this.reservedBit = typedarrayBuffer.alloc(size * size);\n}\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n    var index = row * this.size + col;\n    this.data[index] = value;\n    if (reserved)\n        this.reservedBit[index] = true;\n};\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n    return this.data[row * this.size + col];\n};\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n    this.data[row * this.size + col] ^= value;\n};\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n    return this.reservedBit[row * this.size + col];\n};\nvar bitMatrix = BitMatrix;\nvar alignmentPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Alignment pattern are fixed reference pattern in defined positions\n     * in a matrix symbology, which enables the decode software to re-synchronise\n     * the coordinate mapping of the image modules in the event of moderate amounts\n     * of distortion of the image.\n     *\n     * Alignment patterns are present only in QR Code symbols of version 2 or larger\n     * and their number depends on the symbol version.\n     */\n    var getSymbolSize = utils.getSymbolSize;\n    /**\n     * Calculate the row/column coordinates of the center module of each alignment pattern\n     * for the specified QR Code version.\n     *\n     * The alignment patterns are positioned symmetrically on either side of the diagonal\n     * running from the top left corner of the symbol to the bottom right corner.\n     *\n     * Since positions are simmetrical only half of the coordinates are returned.\n     * Each item of the array will represent in turn the x and y coordinate.\n     * @see {@link getPositions}\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinate\n     */\n    exports.getRowColCoords = function getRowColCoords(version) {\n        if (version === 1)\n            return [];\n        var posCount = Math.floor(version / 7) + 2;\n        var size = getSymbolSize(version);\n        var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n        var positions = [size - 7]; // Last coord is always (size - 7)\n        for (var i = 1; i < posCount - 1; i++) {\n            positions[i] = positions[i - 1] - intervals;\n        }\n        positions.push(6); // First coord is always 6\n        return positions.reverse();\n    };\n    /**\n     * Returns an array containing the positions of each alignment pattern.\n     * Each array's element represent the center point of the pattern as (x, y) coordinates\n     *\n     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n     * and filtering out the items that overlaps with finder pattern\n     *\n     * @example\n     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n     * The alignment patterns, therefore, are to be centered on (row, column)\n     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n     * and are not therefore used for alignment patterns.\n     *\n     * var pos = getPositions(7)\n     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinates\n     */\n    exports.getPositions = function getPositions(version) {\n        var coords = [];\n        var pos = exports.getRowColCoords(version);\n        var posLength = pos.length;\n        for (var i = 0; i < posLength; i++) {\n            for (var j = 0; j < posLength; j++) {\n                // Skip if position is occupied by finder patterns\n                if ((i === 0 && j === 0) || // top-left\n                    (i === 0 && j === posLength - 1) || // bottom-left\n                    (i === posLength - 1 && j === 0)) { // top-right\n                    continue;\n                }\n                coords.push([pos[i], pos[j]]);\n            }\n        }\n        return coords;\n    };\n});\nvar getSymbolSize$1 = utils.getSymbolSize;\nvar FINDER_PATTERN_SIZE = 7;\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nvar getPositions = function getPositions(version) {\n    var size = getSymbolSize$1(version);\n    return [\n        // top-left\n        [0, 0],\n        // top-right\n        [size - FINDER_PATTERN_SIZE, 0],\n        // bottom-left\n        [0, size - FINDER_PATTERN_SIZE]\n    ];\n};\nvar finderPattern = {\n    getPositions: getPositions\n};\nvar maskPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Data mask pattern reference\n     * @type {Object}\n     */\n    exports.Patterns = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n    };\n    /**\n     * Weighted penalty scores for the undesirable features\n     * @type {Object}\n     */\n    var PenaltyScores = {\n        N1: 3,\n        N2: 3,\n        N3: 40,\n        N4: 10\n    };\n    /**\n     * Check if mask pattern value is valid\n     *\n     * @param  {Number}  mask    Mask pattern\n     * @return {Boolean}         true if valid, false otherwise\n     */\n    exports.isValid = function isValid(mask) {\n        return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n    };\n    /**\n     * Returns mask pattern from a value.\n     * If value is not valid, returns undefined\n     *\n     * @param  {Number|String} value        Mask pattern value\n     * @return {Number}                     Valid mask pattern or undefined\n     */\n    exports.from = function from(value) {\n        return exports.isValid(value) ? parseInt(value, 10) : undefined;\n    };\n    /**\n    * Find adjacent modules in row/column with the same color\n    * and assign a penalty value.\n    *\n    * Points: N1 + i\n    * i is the amount by which the number of adjacent modules of the same color exceeds 5\n    */\n    exports.getPenaltyN1 = function getPenaltyN1(data) {\n        var size = data.size;\n        var points = 0;\n        var sameCountCol = 0;\n        var sameCountRow = 0;\n        var lastCol = null;\n        var lastRow = null;\n        for (var row = 0; row < size; row++) {\n            sameCountCol = sameCountRow = 0;\n            lastCol = lastRow = null;\n            for (var col = 0; col < size; col++) {\n                var module = data.get(row, col);\n                if (module === lastCol) {\n                    sameCountCol++;\n                }\n                else {\n                    if (sameCountCol >= 5)\n                        points += PenaltyScores.N1 + (sameCountCol - 5);\n                    lastCol = module;\n                    sameCountCol = 1;\n                }\n                module = data.get(col, row);\n                if (module === lastRow) {\n                    sameCountRow++;\n                }\n                else {\n                    if (sameCountRow >= 5)\n                        points += PenaltyScores.N1 + (sameCountRow - 5);\n                    lastRow = module;\n                    sameCountRow = 1;\n                }\n            }\n            if (sameCountCol >= 5)\n                points += PenaltyScores.N1 + (sameCountCol - 5);\n            if (sameCountRow >= 5)\n                points += PenaltyScores.N1 + (sameCountRow - 5);\n        }\n        return points;\n    };\n    /**\n     * Find 2x2 blocks with the same color and assign a penalty value\n     *\n     * Points: N2 * (m - 1) * (n - 1)\n     */\n    exports.getPenaltyN2 = function getPenaltyN2(data) {\n        var size = data.size;\n        var points = 0;\n        for (var row = 0; row < size - 1; row++) {\n            for (var col = 0; col < size - 1; col++) {\n                var last = data.get(row, col) +\n                    data.get(row, col + 1) +\n                    data.get(row + 1, col) +\n                    data.get(row + 1, col + 1);\n                if (last === 4 || last === 0)\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N2;\n    };\n    /**\n     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n     * preceded or followed by light area 4 modules wide\n     *\n     * Points: N3 * number of pattern found\n     */\n    exports.getPenaltyN3 = function getPenaltyN3(data) {\n        var size = data.size;\n        var points = 0;\n        var bitsCol = 0;\n        var bitsRow = 0;\n        for (var row = 0; row < size; row++) {\n            bitsCol = bitsRow = 0;\n            for (var col = 0; col < size; col++) {\n                bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);\n                if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D))\n                    points++;\n                bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);\n                if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D))\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N3;\n    };\n    /**\n     * Calculate proportion of dark modules in entire symbol\n     *\n     * Points: N4 * k\n     *\n     * k is the rating of the deviation of the proportion of dark modules\n     * in the symbol from 50% in steps of 5%\n     */\n    exports.getPenaltyN4 = function getPenaltyN4(data) {\n        var darkCount = 0;\n        var modulesCount = data.data.length;\n        for (var i = 0; i < modulesCount; i++)\n            darkCount += data.data[i];\n        var k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);\n        return k * PenaltyScores.N4;\n    };\n    /**\n     * Return mask value at given position\n     *\n     * @param  {Number} maskPattern Pattern reference value\n     * @param  {Number} i           Row\n     * @param  {Number} j           Column\n     * @return {Boolean}            Mask value\n     */\n    function getMaskAt(maskPattern, i, j) {\n        switch (maskPattern) {\n            case exports.Patterns.PATTERN000: return (i + j) % 2 === 0;\n            case exports.Patterns.PATTERN001: return i % 2 === 0;\n            case exports.Patterns.PATTERN010: return j % 3 === 0;\n            case exports.Patterns.PATTERN011: return (i + j) % 3 === 0;\n            case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n            case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0;\n            case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;\n            case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;\n            default: throw new Error('bad maskPattern:' + maskPattern);\n        }\n    }\n    /**\n     * Apply a mask pattern to a BitMatrix\n     *\n     * @param  {Number}    pattern Pattern reference number\n     * @param  {BitMatrix} data    BitMatrix data\n     */\n    exports.applyMask = function applyMask(pattern, data) {\n        var size = data.size;\n        for (var col = 0; col < size; col++) {\n            for (var row = 0; row < size; row++) {\n                if (data.isReserved(row, col))\n                    continue;\n                data.xor(row, col, getMaskAt(pattern, row, col));\n            }\n        }\n    };\n    /**\n     * Returns the best mask pattern for data\n     *\n     * @param  {BitMatrix} data\n     * @return {Number} Mask pattern reference number\n     */\n    exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n        var numPatterns = Object.keys(exports.Patterns).length;\n        var bestPattern = 0;\n        var lowerPenalty = Infinity;\n        for (var p = 0; p < numPatterns; p++) {\n            setupFormatFunc(p);\n            exports.applyMask(p, data);\n            // Calculate penalty\n            var penalty = exports.getPenaltyN1(data) +\n                exports.getPenaltyN2(data) +\n                exports.getPenaltyN3(data) +\n                exports.getPenaltyN4(data);\n            // Undo previously applied mask\n            exports.applyMask(p, data);\n            if (penalty < lowerPenalty) {\n                lowerPenalty = penalty;\n                bestPattern = p;\n            }\n        }\n        return bestPattern;\n    };\n});\nvar EC_BLOCKS_TABLE = [\n    // L  M  Q  H\n    1, 1, 1, 1,\n    1, 1, 1, 1,\n    1, 1, 2, 2,\n    1, 2, 2, 4,\n    1, 2, 4, 4,\n    2, 4, 4, 4,\n    2, 4, 6, 5,\n    2, 4, 6, 6,\n    2, 5, 8, 8,\n    4, 5, 8, 8,\n    4, 5, 8, 11,\n    4, 8, 10, 11,\n    4, 9, 12, 16,\n    4, 9, 16, 16,\n    6, 10, 12, 18,\n    6, 10, 17, 16,\n    6, 11, 16, 19,\n    6, 13, 18, 21,\n    7, 14, 21, 25,\n    8, 16, 20, 25,\n    8, 17, 23, 25,\n    9, 17, 23, 34,\n    9, 18, 25, 30,\n    10, 20, 27, 32,\n    12, 21, 29, 35,\n    12, 23, 34, 37,\n    12, 25, 34, 40,\n    13, 26, 35, 42,\n    14, 28, 38, 45,\n    15, 29, 40, 48,\n    16, 31, 43, 51,\n    17, 33, 45, 54,\n    18, 35, 48, 57,\n    19, 37, 51, 60,\n    19, 38, 53, 63,\n    20, 40, 56, 66,\n    21, 43, 59, 70,\n    22, 45, 62, 74,\n    24, 47, 65, 77,\n    25, 49, 68, 81\n];\nvar EC_CODEWORDS_TABLE = [\n    // L  M  Q  H\n    7, 10, 13, 17,\n    10, 16, 22, 28,\n    15, 26, 36, 44,\n    20, 36, 52, 64,\n    26, 48, 72, 88,\n    36, 64, 96, 112,\n    40, 72, 108, 130,\n    48, 88, 132, 156,\n    60, 110, 160, 192,\n    72, 130, 192, 224,\n    80, 150, 224, 264,\n    96, 176, 260, 308,\n    104, 198, 288, 352,\n    120, 216, 320, 384,\n    132, 240, 360, 432,\n    144, 280, 408, 480,\n    168, 308, 448, 532,\n    180, 338, 504, 588,\n    196, 364, 546, 650,\n    224, 416, 600, 700,\n    224, 442, 644, 750,\n    252, 476, 690, 816,\n    270, 504, 750, 900,\n    300, 560, 810, 960,\n    312, 588, 870, 1050,\n    336, 644, 952, 1110,\n    360, 700, 1020, 1200,\n    390, 728, 1050, 1260,\n    420, 784, 1140, 1350,\n    450, 812, 1200, 1440,\n    480, 868, 1290, 1530,\n    510, 924, 1350, 1620,\n    540, 980, 1440, 1710,\n    570, 1036, 1530, 1800,\n    570, 1064, 1590, 1890,\n    600, 1120, 1680, 1980,\n    630, 1204, 1770, 2100,\n    660, 1260, 1860, 2220,\n    720, 1316, 1950, 2310,\n    750, 1372, 2040, 2430\n];\n/**\n * Returns the number of error correction block that the QR Code should contain\n * for the specified version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction blocks\n */\nvar getBlocksCount = function getBlocksCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\n/**\n * Returns the number of error correction codewords to use for the specified\n * version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction codewords\n */\nvar getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\nvar errorCorrectionCode = {\n    getBlocksCount: getBlocksCount,\n    getTotalCodewordsCount: getTotalCodewordsCount\n};\nvar EXP_TABLE = typedarrayBuffer.alloc(512);\nvar LOG_TABLE = typedarrayBuffer.alloc(256);\n(function initTables() {\n    var x = 1;\n    for (var i = 0; i < 255; i++) {\n        EXP_TABLE[i] = x;\n        LOG_TABLE[x] = i;\n        x <<= 1; // multiply by 2\n        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n        // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n            x ^= 0x11D;\n        }\n    }\n    // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n    // stay inside the bounds (because we will mainly use this table for the multiplication of\n    // two GF numbers, no more).\n    // @see {@link mul}\n    for (i = 255; i < 512; i++) {\n        EXP_TABLE[i] = EXP_TABLE[i - 255];\n    }\n}());\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar log = function log(n) {\n    if (n < 1)\n        throw new Error('log(' + n + ')');\n    return LOG_TABLE[n];\n};\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar exp = function exp(n) {\n    return EXP_TABLE[n];\n};\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nvar mul = function mul(x, y) {\n    if (x === 0 || y === 0)\n        return 0;\n    // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n    // @see {@link initTables}\n    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n};\nvar galoisField = {\n    log: log,\n    exp: exp,\n    mul: mul\n};\nvar polynomial = createCommonjsModule(function (module, exports) {\n    /**\n     * Multiplies two polynomials inside Galois Field\n     *\n     * @param  {Buffer} p1 Polynomial\n     * @param  {Buffer} p2 Polynomial\n     * @return {Buffer}    Product of p1 and p2\n     */\n    exports.mul = function mul(p1, p2) {\n        var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);\n        for (var i = 0; i < p1.length; i++) {\n            for (var j = 0; j < p2.length; j++) {\n                coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);\n            }\n        }\n        return coeff;\n    };\n    /**\n     * Calculate the remainder of polynomials division\n     *\n     * @param  {Buffer} divident Polynomial\n     * @param  {Buffer} divisor  Polynomial\n     * @return {Buffer}          Remainder\n     */\n    exports.mod = function mod(divident, divisor) {\n        var result = typedarrayBuffer.from(divident);\n        while ((result.length - divisor.length) >= 0) {\n            var coeff = result[0];\n            for (var i = 0; i < divisor.length; i++) {\n                result[i] ^= galoisField.mul(divisor[i], coeff);\n            }\n            // remove all zeros from buffer head\n            var offset = 0;\n            while (offset < result.length && result[offset] === 0)\n                offset++;\n            result = result.slice(offset);\n        }\n        return result;\n    };\n    /**\n     * Generate an irreducible generator polynomial of specified degree\n     * (used by Reed-Solomon encoder)\n     *\n     * @param  {Number} degree Degree of the generator polynomial\n     * @return {Buffer}        Buffer containing polynomial coefficients\n     */\n    exports.generateECPolynomial = function generateECPolynomial(degree) {\n        var poly = typedarrayBuffer.from([1]);\n        for (var i = 0; i < degree; i++) {\n            poly = exports.mul(poly, [1, galoisField.exp(i)]);\n        }\n        return poly;\n    };\n});\nvar Buffer$1 = buffer.Buffer;\nfunction ReedSolomonEncoder(degree) {\n    this.genPoly = undefined;\n    this.degree = degree;\n    if (this.degree)\n        this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n    // create an irreducible generator polynomial\n    this.degree = degree;\n    this.genPoly = polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode(data) {\n    if (!this.genPoly) {\n        throw new Error('Encoder not initialized');\n    }\n    // Calculate EC for this data block\n    // extends data size to data+genPoly size\n    var pad = typedarrayBuffer.alloc(this.degree);\n    var paddedData = Buffer$1.concat([data, pad], data.length + this.degree);\n    // The error correction codewords are the remainder after dividing the data codewords\n    // by a generator polynomial\n    var remainder = polynomial.mod(paddedData, this.genPoly);\n    // return EC data blocks (last n byte, where n is the degree of genPoly)\n    // If coefficients number in remainder are less than genPoly degree,\n    // pad with 0s to the left to reach the needed number of coefficients\n    var start = this.degree - remainder.length;\n    if (start > 0) {\n        var buff = typedarrayBuffer.alloc(this.degree);\n        remainder.copy(buff, start);\n        return buff;\n    }\n    return remainder;\n};\nvar reedSolomonEncoder = ReedSolomonEncoder;\n/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nvar isValid = function isValid(version) {\n    return !isNaN(version) && version >= 1 && version <= 40;\n};\nvar versionCheck = {\n    isValid: isValid\n};\nvar numeric = '[0-9]+';\nvar alphanumeric = '[A-Z $%*+\\\\-./:]+';\nvar kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n    '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n    '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n    '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\nkanji = kanji.replace(/u/g, '\\\\u');\nvar byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\nvar KANJI = new RegExp(kanji, 'g');\nvar BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\nvar BYTE = new RegExp(byte, 'g');\nvar NUMERIC = new RegExp(numeric, 'g');\nvar ALPHANUMERIC = new RegExp(alphanumeric, 'g');\nvar TEST_KANJI = new RegExp('^' + kanji + '$');\nvar TEST_NUMERIC = new RegExp('^' + numeric + '$');\nvar TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\nvar testKanji = function testKanji(str) {\n    return TEST_KANJI.test(str);\n};\nvar testNumeric = function testNumeric(str) {\n    return TEST_NUMERIC.test(str);\n};\nvar testAlphanumeric = function testAlphanumeric(str) {\n    return TEST_ALPHANUMERIC.test(str);\n};\nvar regex = {\n    KANJI: KANJI,\n    BYTE_KANJI: BYTE_KANJI,\n    BYTE: BYTE,\n    NUMERIC: NUMERIC,\n    ALPHANUMERIC: ALPHANUMERIC,\n    testKanji: testKanji,\n    testNumeric: testNumeric,\n    testAlphanumeric: testAlphanumeric\n};\nvar mode = createCommonjsModule(function (module, exports) {\n    /**\n     * Numeric mode encodes data from the decimal digit set (0 - 9)\n     * (byte values 30HEX to 39HEX).\n     * Normally, 3 data characters are represented by 10 bits.\n     *\n     * @type {Object}\n     */\n    exports.NUMERIC = {\n        id: 'Numeric',\n        bit: 1 << 0,\n        ccBits: [10, 12, 14]\n    };\n    /**\n     * Alphanumeric mode encodes data from a set of 45 characters,\n     * i.e. 10 numeric digits (0 - 9),\n     *      26 alphabetic characters (A - Z),\n     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n     * Normally, two input characters are represented by 11 bits.\n     *\n     * @type {Object}\n     */\n    exports.ALPHANUMERIC = {\n        id: 'Alphanumeric',\n        bit: 1 << 1,\n        ccBits: [9, 11, 13]\n    };\n    /**\n     * In byte mode, data is encoded at 8 bits per character.\n     *\n     * @type {Object}\n     */\n    exports.BYTE = {\n        id: 'Byte',\n        bit: 1 << 2,\n        ccBits: [8, 16, 16]\n    };\n    /**\n     * The Kanji mode efficiently encodes Kanji characters in accordance with\n     * the Shift JIS system based on JIS X 0208.\n     * The Shift JIS values are shifted from the JIS X 0208 values.\n     * JIS X 0208 gives details of the shift coded representation.\n     * Each two-byte character value is compacted to a 13-bit binary codeword.\n     *\n     * @type {Object}\n     */\n    exports.KANJI = {\n        id: 'Kanji',\n        bit: 1 << 3,\n        ccBits: [8, 10, 12]\n    };\n    /**\n     * Mixed mode will contain a sequences of data in a combination of any of\n     * the modes described above\n     *\n     * @type {Object}\n     */\n    exports.MIXED = {\n        bit: -1\n    };\n    /**\n     * Returns the number of bits needed to store the data length\n     * according to QR Code specifications.\n     *\n     * @param  {Mode}   mode    Data mode\n     * @param  {Number} version QR Code version\n     * @return {Number}         Number of bits\n     */\n    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n        if (!mode.ccBits)\n            throw new Error('Invalid mode: ' + mode);\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid version: ' + version);\n        }\n        if (version >= 1 && version < 10)\n            return mode.ccBits[0];\n        else if (version < 27)\n            return mode.ccBits[1];\n        return mode.ccBits[2];\n    };\n    /**\n     * Returns the most efficient mode to store the specified data\n     *\n     * @param  {String} dataStr Input data string\n     * @return {Mode}           Best mode\n     */\n    exports.getBestModeForData = function getBestModeForData(dataStr) {\n        if (regex.testNumeric(dataStr))\n            return exports.NUMERIC;\n        else if (regex.testAlphanumeric(dataStr))\n            return exports.ALPHANUMERIC;\n        else if (regex.testKanji(dataStr))\n            return exports.KANJI;\n        else\n            return exports.BYTE;\n    };\n    /**\n     * Return mode name as string\n     *\n     * @param {Mode} mode Mode object\n     * @returns {String}  Mode name\n     */\n    exports.toString = function toString(mode) {\n        if (mode && mode.id)\n            return mode.id;\n        throw new Error('Invalid mode');\n    };\n    /**\n     * Check if input param is a valid mode object\n     *\n     * @param   {Mode}    mode Mode object\n     * @returns {Boolean} True if valid mode, false otherwise\n     */\n    exports.isValid = function isValid(mode) {\n        return mode && mode.bit && mode.ccBits;\n    };\n    /**\n     * Get mode object from its name\n     *\n     * @param   {String} string Mode name\n     * @returns {Mode}          Mode object\n     */\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'numeric':\n                return exports.NUMERIC;\n            case 'alphanumeric':\n                return exports.ALPHANUMERIC;\n            case 'kanji':\n                return exports.KANJI;\n            case 'byte':\n                return exports.BYTE;\n            default:\n                throw new Error('Unknown mode: ' + string);\n        }\n    }\n    /**\n     * Returns mode from a value.\n     * If value is not a valid mode, returns defaultValue\n     *\n     * @param  {Mode|String} value        Encoding mode\n     * @param  {Mode}        defaultValue Fallback value\n     * @return {Mode}                     Encoding mode\n     */\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nvar version = createCommonjsModule(function (module, exports) {\n    // Generator polynomial used to encode version information\n    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);\n    var G18_BCH = utils.getBCHDigit(G18);\n    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    function getReservedBitsCount(mode$1, version) {\n        // Character count indicator + mode indicator bits\n        return mode.getCharCountIndicator(mode$1, version) + 4;\n    }\n    function getTotalBitsFromDataArray(segments, version) {\n        var totalBits = 0;\n        segments.forEach(function (data) {\n            var reservedBits = getReservedBitsCount(data.mode, version);\n            totalBits += reservedBits + data.getBitsLength();\n        });\n        return totalBits;\n    }\n    function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            var length = getTotalBitsFromDataArray(segments, currentVersion);\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns version number from a value.\n     * If value is not a valid version, returns defaultValue\n     *\n     * @param  {Number|String} value        QR Code version\n     * @param  {Number}        defaultValue Fallback value\n     * @return {Number}                     QR Code version number\n     */\n    exports.from = function from(value, defaultValue) {\n        if (versionCheck.isValid(value)) {\n            return parseInt(value, 10);\n        }\n        return defaultValue;\n    };\n    /**\n     * Returns how much data can be stored with the specified QR code version\n     * and error correction level\n     *\n     * @param  {Number} version              QR Code version (1-40)\n     * @param  {Number} errorCorrectionLevel Error correction level\n     * @param  {Mode}   mode                 Data mode\n     * @return {Number}                      Quantity of storable data\n     */\n    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode$1) {\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid QR Code version');\n        }\n        // Use Byte mode as default\n        if (typeof mode$1 === 'undefined')\n            mode$1 = mode.BYTE;\n        // Total codewords for this QR code version (Data + Error correction)\n        var totalCodewords = utils.getSymbolTotalCodewords(version);\n        // Total number of error correction codewords\n        var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n        // Total number of data codewords\n        var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n        if (mode$1 === mode.MIXED)\n            return dataTotalCodewordsBits;\n        var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version);\n        // Return max number of storable codewords\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return Math.floor((usableBits / 10) * 3);\n            case mode.ALPHANUMERIC:\n                return Math.floor((usableBits / 11) * 2);\n            case mode.KANJI:\n                return Math.floor(usableBits / 13);\n            case mode.BYTE:\n            default:\n                return Math.floor(usableBits / 8);\n        }\n    };\n    /**\n     * Returns the minimum version needed to contain the amount of data\n     *\n     * @param  {Segment} data                    Segment of data\n     * @param  {Number} [errorCorrectionLevel=H] Error correction level\n     * @param  {Mode} mode                       Data mode\n     * @return {Number}                          QR Code version\n     */\n    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel$1) {\n        var seg;\n        var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);\n        if (isarray(data)) {\n            if (data.length > 1) {\n                return getBestVersionForMixedData(data, ecl);\n            }\n            if (data.length === 0) {\n                return 1;\n            }\n            seg = data[0];\n        }\n        else {\n            seg = data;\n        }\n        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n    };\n    /**\n     * Returns version information with relative error correction bits\n     *\n     * The version information is included in QR Code symbols of version 7 or larger.\n     * It consists of an 18-bit sequence containing 6 data bits,\n     * with 12 error correction bits calculated using the (18, 6) Golay code.\n     *\n     * @param  {Number} version QR Code version\n     * @return {Number}         Encoded version info bits\n     */\n    exports.getEncodedBits = function getEncodedBits(version) {\n        if (!versionCheck.isValid(version) || version < 7) {\n            throw new Error('Invalid QR Code version');\n        }\n        var d = version << 12;\n        while (utils.getBCHDigit(d) - G18_BCH >= 0) {\n            d ^= (G18 << (utils.getBCHDigit(d) - G18_BCH));\n        }\n        return (version << 12) | d;\n    };\n});\nvar G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);\nvar G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\nvar G15_BCH = utils.getBCHDigit(G15);\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nvar getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n    var data = ((errorCorrectionLevel.bit << 3) | mask);\n    var d = data << 10;\n    while (utils.getBCHDigit(d) - G15_BCH >= 0) {\n        d ^= (G15 << (utils.getBCHDigit(d) - G15_BCH));\n    }\n    // xor final data with mask pattern in order to ensure that\n    // no combination of Error Correction Level and data mask pattern\n    // will result in an all-zero data string\n    return ((data << 10) | d) ^ G15_MASK;\n};\nvar formatInfo = {\n    getEncodedBits: getEncodedBits\n};\nfunction NumericData(data) {\n    this.mode = mode.NUMERIC;\n    this.data = data.toString();\n}\nNumericData.getBitsLength = function getBitsLength(length) {\n    return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0);\n};\nNumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nNumericData.prototype.getBitsLength = function getBitsLength() {\n    return NumericData.getBitsLength(this.data.length);\n};\nNumericData.prototype.write = function write(bitBuffer) {\n    var i, group, value;\n    // The input data string is divided into groups of three digits,\n    // and each group is converted to its 10-bit binary equivalent.\n    for (i = 0; i + 3 <= this.data.length; i += 3) {\n        group = this.data.substr(i, 3);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, 10);\n    }\n    // If the number of input digits is not an exact multiple of three,\n    // the final one or two digits are converted to 4 or 7 bits respectively.\n    var remainingNum = this.data.length - i;\n    if (remainingNum > 0) {\n        group = this.data.substr(i);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, remainingNum * 3 + 1);\n    }\n};\nvar numericData = NumericData;\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nvar ALPHA_NUM_CHARS = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n];\nfunction AlphanumericData(data) {\n    this.mode = mode.ALPHANUMERIC;\n    this.data = data;\n}\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n    return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\nAlphanumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n    return AlphanumericData.getBitsLength(this.data.length);\n};\nAlphanumericData.prototype.write = function write(bitBuffer) {\n    var i;\n    // Input data characters are divided into groups of two characters\n    // and encoded as 11-bit binary codes.\n    for (i = 0; i + 2 <= this.data.length; i += 2) {\n        // The character value of the first character is multiplied by 45\n        var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n        // The character value of the second digit is added to the product\n        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n        // The sum is then stored as 11-bit binary number\n        bitBuffer.put(value, 11);\n    }\n    // If the number of input data characters is not a multiple of two,\n    // the character value of the final character is encoded as a 6-bit binary number.\n    if (this.data.length % 2) {\n        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n    }\n};\nvar alphanumericData = AlphanumericData;\nfunction ByteData(data) {\n    this.mode = mode.BYTE;\n    this.data = typedarrayBuffer.from(data);\n}\nByteData.getBitsLength = function getBitsLength(length) {\n    return length * 8;\n};\nByteData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nByteData.prototype.getBitsLength = function getBitsLength() {\n    return ByteData.getBitsLength(this.data.length);\n};\nByteData.prototype.write = function (bitBuffer) {\n    for (var i = 0, l = this.data.length; i < l; i++) {\n        bitBuffer.put(this.data[i], 8);\n    }\n};\nvar byteData = ByteData;\nfunction KanjiData(data) {\n    this.mode = mode.KANJI;\n    this.data = data;\n}\nKanjiData.getBitsLength = function getBitsLength(length) {\n    return length * 13;\n};\nKanjiData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nKanjiData.prototype.getBitsLength = function getBitsLength() {\n    return KanjiData.getBitsLength(this.data.length);\n};\nKanjiData.prototype.write = function (bitBuffer) {\n    var i;\n    // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n    // These byte values are shifted from the JIS X 0208 values.\n    // JIS X 0208 gives details of the shift coded representation.\n    for (i = 0; i < this.data.length; i++) {\n        var value = utils.toSJIS(this.data[i]);\n        // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n        if (value >= 0x8140 && value <= 0x9FFC) {\n            // Subtract 0x8140 from Shift JIS value\n            value -= 0x8140;\n            // For characters with Shift JIS values from 0xE040 to 0xEBBF\n        }\n        else if (value >= 0xE040 && value <= 0xEBBF) {\n            // Subtract 0xC140 from Shift JIS value\n            value -= 0xC140;\n        }\n        else {\n            throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' +\n                'Make sure your charset is UTF-8');\n        }\n        // Multiply most significant byte of result by 0xC0\n        // and add least significant byte to product\n        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);\n        // Convert result to a 13-bit binary string\n        bitBuffer.put(value, 13);\n    }\n};\nvar kanjiData = KanjiData;\nvar dijkstra_1 = createCommonjsModule(function (module) {\n    /******************************************************************************\n     * Created 2008-08-19.\n     *\n     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n     *\n     * Copyright (C) 2008\n     *   Wyatt Baldwin <self@wyattbaldwin.com>\n     *   All rights reserved\n     *\n     * Licensed under the MIT license.\n     *\n     *   http://www.opensource.org/licenses/mit-license.php\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     *****************************************************************************/\n    var dijkstra = {\n        single_source_shortest_paths: function (graph, s, d) {\n            // Predecessor map for each node that has been encountered.\n            // node ID => predecessor node ID\n            var predecessors = {};\n            // Costs of shortest paths from s to all nodes encountered.\n            // node ID => cost\n            var costs = {};\n            costs[s] = 0;\n            // Costs of shortest paths from s to all nodes encountered; differs from\n            // `costs` in that it provides easy access to the node that currently has\n            // the known shortest path from s.\n            // XXX: Do we actually need both `costs` and `open`?\n            var open = dijkstra.PriorityQueue.make();\n            open.push(s, 0);\n            var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n            while (!open.empty()) {\n                // In the nodes remaining in graph that have a known cost from s,\n                // find the node, u, that currently has the shortest path from s.\n                closest = open.pop();\n                u = closest.value;\n                cost_of_s_to_u = closest.cost;\n                // Get nodes adjacent to u...\n                adjacent_nodes = graph[u] || {};\n                // ...and explore the edges that connect u to those nodes, updating\n                // the cost of the shortest paths to any or all of those nodes as\n                // necessary. v is the node across the current edge from u.\n                for (v in adjacent_nodes) {\n                    if (adjacent_nodes.hasOwnProperty(v)) {\n                        // Get the cost of the edge running from u to v.\n                        cost_of_e = adjacent_nodes[v];\n                        // Cost of s to u plus the cost of u to v across e--this is *a*\n                        // cost from s to v that may or may not be less than the current\n                        // known cost to v.\n                        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n                        // If we haven't visited v yet OR if the current known cost from s to\n                        // v is greater than the new cost we just found (cost of s to u plus\n                        // cost of u to v across e), update v's cost in the cost list and\n                        // update v's predecessor in the predecessor list (it's now u).\n                        cost_of_s_to_v = costs[v];\n                        first_visit = (typeof costs[v] === 'undefined');\n                        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n                            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n                            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n                            predecessors[v] = u;\n                        }\n                    }\n                }\n            }\n            if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n                var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n                throw new Error(msg);\n            }\n            return predecessors;\n        },\n        extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n            var nodes = [];\n            var u = d;\n            while (u) {\n                nodes.push(u);\n                u = predecessors[u];\n            }\n            nodes.reverse();\n            return nodes;\n        },\n        find_path: function (graph, s, d) {\n            var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n            return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n        },\n        /**\n         * A very naive priority queue implementation.\n         */\n        PriorityQueue: {\n            make: function (opts) {\n                var T = dijkstra.PriorityQueue, t = {}, key;\n                opts = opts || {};\n                for (key in T) {\n                    if (T.hasOwnProperty(key)) {\n                        t[key] = T[key];\n                    }\n                }\n                t.queue = [];\n                t.sorter = opts.sorter || T.default_sorter;\n                return t;\n            },\n            default_sorter: function (a, b) {\n                return a.cost - b.cost;\n            },\n            /**\n             * Add a new item to the queue and ensure the highest priority element\n             * is at the front of the queue.\n             */\n            push: function (value, cost) {\n                var item = { value: value, cost: cost };\n                this.queue.push(item);\n                this.queue.sort(this.sorter);\n            },\n            /**\n             * Return the highest priority element in the queue.\n             */\n            pop: function () {\n                return this.queue.shift();\n            },\n            empty: function () {\n                return this.queue.length === 0;\n            }\n        }\n    };\n    // node.js module exports\n    {\n        module.exports = dijkstra;\n    }\n});\nvar segments = createCommonjsModule(function (module, exports) {\n    /**\n     * Returns UTF8 byte length\n     *\n     * @param  {String} str Input string\n     * @return {Number}     Number of byte\n     */\n    function getStringByteLength(str) {\n        return unescape(encodeURIComponent(str)).length;\n    }\n    /**\n     * Get a list of segments of the specified mode\n     * from a string\n     *\n     * @param  {Mode}   mode Segment mode\n     * @param  {String} str  String to process\n     * @return {Array}       Array of object with segments data\n     */\n    function getSegments(regex, mode, str) {\n        var segments = [];\n        var result;\n        while ((result = regex.exec(str)) !== null) {\n            segments.push({\n                data: result[0],\n                index: result.index,\n                mode: mode,\n                length: result[0].length\n            });\n        }\n        return segments;\n    }\n    /**\n     * Extracts a series of segments with the appropriate\n     * modes from a string\n     *\n     * @param  {String} dataStr Input string\n     * @return {Array}          Array of object with segments data\n     */\n    function getSegmentsFromString(dataStr) {\n        var numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);\n        var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);\n        var byteSegs;\n        var kanjiSegs;\n        if (utils.isKanjiModeEnabled()) {\n            byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);\n            kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);\n        }\n        else {\n            byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);\n            kanjiSegs = [];\n        }\n        var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n        return segs\n            .sort(function (s1, s2) {\n            return s1.index - s2.index;\n        })\n            .map(function (obj) {\n            return {\n                data: obj.data,\n                mode: obj.mode,\n                length: obj.length\n            };\n        });\n    }\n    /**\n     * Returns how many bits are needed to encode a string of\n     * specified length with the specified mode\n     *\n     * @param  {Number} length String length\n     * @param  {Mode} mode     Segment mode\n     * @return {Number}        Bit length\n     */\n    function getSegmentBitsLength(length, mode$1) {\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return numericData.getBitsLength(length);\n            case mode.ALPHANUMERIC:\n                return alphanumericData.getBitsLength(length);\n            case mode.KANJI:\n                return kanjiData.getBitsLength(length);\n            case mode.BYTE:\n                return byteData.getBitsLength(length);\n        }\n    }\n    /**\n     * Merges adjacent segments which have the same mode\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function mergeSegments(segs) {\n        return segs.reduce(function (acc, curr) {\n            var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n            if (prevSeg && prevSeg.mode === curr.mode) {\n                acc[acc.length - 1].data += curr.data;\n                return acc;\n            }\n            acc.push(curr);\n            return acc;\n        }, []);\n    }\n    /**\n     * Generates a list of all possible nodes combination which\n     * will be used to build a segments graph.\n     *\n     * Nodes are divided by groups. Each group will contain a list of all the modes\n     * in which is possible to encode the given text.\n     *\n     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n     * The group for '12345' will contain then 3 objects, one for each\n     * possible encoding mode.\n     *\n     * Each node represents a possible segment.\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function buildNodes(segs) {\n        var nodes = [];\n        for (var i = 0; i < segs.length; i++) {\n            var seg = segs[i];\n            switch (seg.mode) {\n                case mode.NUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.ALPHANUMERIC, length: seg.length },\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.ALPHANUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.KANJI:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n                    break;\n                case mode.BYTE:\n                    nodes.push([\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n            }\n        }\n        return nodes;\n    }\n    /**\n     * Builds a graph from a list of nodes.\n     * All segments in each node group will be connected with all the segments of\n     * the next group and so on.\n     *\n     * At each connection will be assigned a weight depending on the\n     * segment's byte length.\n     *\n     * @param  {Array} nodes    Array of object with segments data\n     * @param  {Number} version QR Code version\n     * @return {Object}         Graph of all possible segments\n     */\n    function buildGraph(nodes, version) {\n        var table = {};\n        var graph = { 'start': {} };\n        var prevNodeIds = ['start'];\n        for (var i = 0; i < nodes.length; i++) {\n            var nodeGroup = nodes[i];\n            var currentNodeIds = [];\n            for (var j = 0; j < nodeGroup.length; j++) {\n                var node = nodeGroup[j];\n                var key = '' + i + j;\n                currentNodeIds.push(key);\n                table[key] = { node: node, lastCount: 0 };\n                graph[key] = {};\n                for (var n = 0; n < prevNodeIds.length; n++) {\n                    var prevNodeId = prevNodeIds[n];\n                    if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n                        graph[prevNodeId][key] =\n                            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n                                getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n                        table[prevNodeId].lastCount += node.length;\n                    }\n                    else {\n                        if (table[prevNodeId])\n                            table[prevNodeId].lastCount = node.length;\n                        graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n                            4 + mode.getCharCountIndicator(node.mode, version); // switch cost\n                    }\n                }\n            }\n            prevNodeIds = currentNodeIds;\n        }\n        for (n = 0; n < prevNodeIds.length; n++) {\n            graph[prevNodeIds[n]]['end'] = 0;\n        }\n        return { map: graph, table: table };\n    }\n    /**\n     * Builds a segment from a specified data and mode.\n     * If a mode is not specified, the more suitable will be used.\n     *\n     * @param  {String} data             Input data\n     * @param  {Mode | String} modesHint Data mode\n     * @return {Segment}                 Segment\n     */\n    function buildSingleSegment(data, modesHint) {\n        var mode$1;\n        var bestMode = mode.getBestModeForData(data);\n        mode$1 = mode.from(modesHint, bestMode);\n        // Make sure data can be encoded\n        if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {\n            throw new Error('\"' + data + '\"' +\n                ' cannot be encoded with mode ' + mode.toString(mode$1) +\n                '.\\n Suggested mode is: ' + mode.toString(bestMode));\n        }\n        // Use Mode.BYTE if Kanji support is disabled\n        if (mode$1 === mode.KANJI && !utils.isKanjiModeEnabled()) {\n            mode$1 = mode.BYTE;\n        }\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return new numericData(data);\n            case mode.ALPHANUMERIC:\n                return new alphanumericData(data);\n            case mode.KANJI:\n                return new kanjiData(data);\n            case mode.BYTE:\n                return new byteData(data);\n        }\n    }\n    /**\n     * Builds a list of segments from an array.\n     * Array can contain Strings or Objects with segment's info.\n     *\n     * For each item which is a string, will be generated a segment with the given\n     * string and the more appropriate encoding mode.\n     *\n     * For each item which is an object, will be generated a segment with the given\n     * data and mode.\n     * Objects must contain at least the property \"data\".\n     * If property \"mode\" is not present, the more suitable mode will be used.\n     *\n     * @param  {Array} array Array of objects with segments data\n     * @return {Array}       Array of Segments\n     */\n    exports.fromArray = function fromArray(array) {\n        return array.reduce(function (acc, seg) {\n            if (typeof seg === 'string') {\n                acc.push(buildSingleSegment(seg, null));\n            }\n            else if (seg.data) {\n                acc.push(buildSingleSegment(seg.data, seg.mode));\n            }\n            return acc;\n        }, []);\n    };\n    /**\n     * Builds an optimized sequence of segments from a string,\n     * which will produce the shortest possible bitstream.\n     *\n     * @param  {String} data    Input string\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of segments\n     */\n    exports.fromString = function fromString(data, version) {\n        var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());\n        var nodes = buildNodes(segs);\n        var graph = buildGraph(nodes, version);\n        var path = dijkstra_1.find_path(graph.map, 'start', 'end');\n        var optimizedSegs = [];\n        for (var i = 1; i < path.length - 1; i++) {\n            optimizedSegs.push(graph.table[path[i]].node);\n        }\n        return exports.fromArray(mergeSegments(optimizedSegs));\n    };\n    /**\n     * Splits a string in various segments with the modes which\n     * best represent their content.\n     * The produced segments are far from being optimized.\n     * The output of this function is only used to estimate a QR Code version\n     * which may contain the data.\n     *\n     * @param  {string} data Input string\n     * @return {Array}       Array of segments\n     */\n    exports.rawSplit = function rawSplit(data) {\n        return exports.fromArray(getSegmentsFromString(data, utils.isKanjiModeEnabled()));\n    };\n});\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern(matrix, version) {\n    var size = matrix.size;\n    var pos = finderPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -1; r <= 7; r++) {\n            if (row + r <= -1 || size <= row + r)\n                continue;\n            for (var c = -1; c <= 7; c++) {\n                if (col + c <= -1 || size <= col + c)\n                    continue;\n                if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n                    (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n                    (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern(matrix) {\n    var size = matrix.size;\n    for (var r = 8; r < size - 8; r++) {\n        var value = r % 2 === 0;\n        matrix.set(r, 6, value, true);\n        matrix.set(6, r, value, true);\n    }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern(matrix, version) {\n    var pos = alignmentPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -2; r <= 2; r++) {\n            for (var c = -2; c <= 2; c++) {\n                if (r === -2 || r === 2 || c === -2 || c === 2 ||\n                    (r === 0 && c === 0)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo(matrix, version$1) {\n    var size = matrix.size;\n    var bits = version.getEncodedBits(version$1);\n    var row, col, mod;\n    for (var i = 0; i < 18; i++) {\n        row = Math.floor(i / 3);\n        col = i % 3 + size - 8 - 3;\n        mod = ((bits >> i) & 1) === 1;\n        matrix.set(row, col, mod, true);\n        matrix.set(col, row, mod, true);\n    }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n    var size = matrix.size;\n    var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n    var i, mod;\n    for (i = 0; i < 15; i++) {\n        mod = ((bits >> i) & 1) === 1;\n        // vertical\n        if (i < 6) {\n            matrix.set(i, 8, mod, true);\n        }\n        else if (i < 8) {\n            matrix.set(i + 1, 8, mod, true);\n        }\n        else {\n            matrix.set(size - 15 + i, 8, mod, true);\n        }\n        // horizontal\n        if (i < 8) {\n            matrix.set(8, size - i - 1, mod, true);\n        }\n        else if (i < 9) {\n            matrix.set(8, 15 - i - 1 + 1, mod, true);\n        }\n        else {\n            matrix.set(8, 15 - i - 1, mod, true);\n        }\n    }\n    // fixed module\n    matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData(matrix, data) {\n    var size = matrix.size;\n    var inc = -1;\n    var row = size - 1;\n    var bitIndex = 7;\n    var byteIndex = 0;\n    for (var col = size - 1; col > 0; col -= 2) {\n        if (col === 6)\n            col--;\n        while (true) {\n            for (var c = 0; c < 2; c++) {\n                if (!matrix.isReserved(row, col - c)) {\n                    var dark = false;\n                    if (byteIndex < data.length) {\n                        dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);\n                    }\n                    matrix.set(row, col - c, dark);\n                    bitIndex--;\n                    if (bitIndex === -1) {\n                        byteIndex++;\n                        bitIndex = 7;\n                    }\n                }\n            }\n            row += inc;\n            if (row < 0 || size <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n            }\n        }\n    }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData(version, errorCorrectionLevel, segments) {\n    // Prepare data buffer\n    var buffer = new bitBuffer();\n    segments.forEach(function (data) {\n        // prefix data with mode indicator (4 bits)\n        buffer.put(data.mode.bit, 4);\n        // Prefix data with character count indicator.\n        // The character count indicator is a string of bits that represents the\n        // number of characters that are being encoded.\n        // The character count indicator must be placed after the mode indicator\n        // and must be a certain number of bits long, depending on the QR version\n        // and data mode\n        // @see {@link Mode.getCharCountIndicator}.\n        buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version));\n        // add binary data sequence to buffer\n        data.write(buffer);\n    });\n    // Calculate required number of bits\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    // Add a terminator.\n    // If the bit string is shorter than the total number of required bits,\n    // a terminator of up to four 0s must be added to the right side of the string.\n    // If the bit string is more than four bits shorter than the required number of bits,\n    // add four 0s to the end.\n    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n        buffer.put(0, 4);\n    }\n    // If the bit string is fewer than four bits shorter, add only the number of 0s that\n    // are needed to reach the required number of bits.\n    // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n    // pad the string on the right with 0s to make the string's length a multiple of 8.\n    while (buffer.getLengthInBits() % 8 !== 0) {\n        buffer.putBit(0);\n    }\n    // Add pad bytes if the string is still shorter than the total number of required bits.\n    // Extend the buffer to fill the data capacity of the symbol corresponding to\n    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n    // and 00010001 (0x11) alternately.\n    var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n    for (var i = 0; i < remainingByte; i++) {\n        buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n    }\n    return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n    // Total codewords for this QR code version (Data + Error correction)\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    // Total number of error correction codewords\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    // Total number of data codewords\n    var dataTotalCodewords = totalCodewords - ecTotalCodewords;\n    // Total number of blocks\n    var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);\n    // Calculate how many blocks each group should contain\n    var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n    var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n    var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n    // Number of EC codewords is the same for both groups\n    var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n    // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n    var rs = new reedSolomonEncoder(ecCount);\n    var offset = 0;\n    var dcData = new Array(ecTotalBlocks);\n    var ecData = new Array(ecTotalBlocks);\n    var maxDataSize = 0;\n    var buffer = typedarrayBuffer.from(bitBuffer.buffer);\n    // Divide the buffer into the required number of blocks\n    for (var b = 0; b < ecTotalBlocks; b++) {\n        var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n        // extract a block of data from buffer\n        dcData[b] = buffer.slice(offset, offset + dataSize);\n        // Calculate EC codewords for this data block\n        ecData[b] = rs.encode(dcData[b]);\n        offset += dataSize;\n        maxDataSize = Math.max(maxDataSize, dataSize);\n    }\n    // Create final data\n    // Interleave the data and error correction codewords from each block\n    var data = typedarrayBuffer.alloc(totalCodewords);\n    var index = 0;\n    var i, r;\n    // Add data codewords\n    for (i = 0; i < maxDataSize; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            if (i < dcData[r].length) {\n                data[index++] = dcData[r][i];\n            }\n        }\n    }\n    // Apped EC codewords\n    for (i = 0; i < ecCount; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            data[index++] = ecData[r][i];\n        }\n    }\n    return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol(data, version$1, errorCorrectionLevel, maskPattern$1) {\n    var segments$1;\n    if (isarray(data)) {\n        segments$1 = segments.fromArray(data);\n    }\n    else if (typeof data === 'string') {\n        var estimatedVersion = version$1;\n        if (!estimatedVersion) {\n            var rawSegments = segments.rawSplit(data);\n            // Estimate best version that can contain raw splitted segments\n            estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n        }\n        // Build optimized segments\n        // If estimated version is undefined, try with the highest version\n        segments$1 = segments.fromString(data, estimatedVersion || 40);\n    }\n    else {\n        throw new Error('Invalid data');\n    }\n    // Get the min version that can contain data\n    var bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel);\n    // If no version is found, data cannot be stored\n    if (!bestVersion) {\n        throw new Error('The amount of data is too big to be stored in a QR Code');\n    }\n    // If not specified, use min version as default\n    if (!version$1) {\n        version$1 = bestVersion;\n        // Check if the specified version can contain the data\n    }\n    else if (version$1 < bestVersion) {\n        throw new Error('\\n' +\n            'The chosen QR Code version cannot contain this amount of data.\\n' +\n            'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n    }\n    var dataBits = createData(version$1, errorCorrectionLevel, segments$1);\n    // Allocate matrix buffer\n    var moduleCount = utils.getSymbolSize(version$1);\n    var modules = new bitMatrix(moduleCount);\n    // Add function modules\n    setupFinderPattern(modules, version$1);\n    setupTimingPattern(modules);\n    setupAlignmentPattern(modules, version$1);\n    // Add temporary dummy bits for format info just to set them as reserved.\n    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n    // since the masking operation must be performed only on the encoding region.\n    // These blocks will be replaced with correct values later in code.\n    setupFormatInfo(modules, errorCorrectionLevel, 0);\n    if (version$1 >= 7) {\n        setupVersionInfo(modules, version$1);\n    }\n    // Add data codewords\n    setupData(modules, dataBits);\n    if (isNaN(maskPattern$1)) {\n        // Find best mask pattern\n        maskPattern$1 = maskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n    }\n    // Apply mask pattern\n    maskPattern.applyMask(maskPattern$1, modules);\n    // Replace format info bits with correct values\n    setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);\n    return {\n        modules: modules,\n        version: version$1,\n        errorCorrectionLevel: errorCorrectionLevel,\n        maskPattern: maskPattern$1,\n        segments: segments$1\n    };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nvar create = function create(data, options) {\n    if (typeof data === 'undefined' || data === '') {\n        throw new Error('No input text');\n    }\n    var errorCorrectionLevel$1 = errorCorrectionLevel.M;\n    var version$1;\n    var mask;\n    if (typeof options !== 'undefined') {\n        // Use higher error correction level as default\n        errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);\n        version$1 = version.from(options.version);\n        mask = maskPattern.from(options.maskPattern);\n        if (options.toSJISFunc) {\n            utils.setToSJISFunction(options.toSJISFunc);\n        }\n    }\n    return createSymbol(data, version$1, errorCorrectionLevel$1, mask);\n};\nvar qrcode = {\n    create: create\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    function hex2rgba(hex) {\n        if (typeof hex === 'number') {\n            hex = hex.toString();\n        }\n        if (typeof hex !== 'string') {\n            throw new Error('Color should be defined as hex string');\n        }\n        var hexCode = hex.slice().replace('#', '').split('');\n        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n            throw new Error('Invalid hex color: ' + hex);\n        }\n        // Convert from short to long form (fff -> ffffff)\n        if (hexCode.length === 3 || hexCode.length === 4) {\n            hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n                return [c, c];\n            }));\n        }\n        // Add default alpha value\n        if (hexCode.length === 6)\n            hexCode.push('F', 'F');\n        var hexValue = parseInt(hexCode.join(''), 16);\n        return {\n            r: (hexValue >> 24) & 255,\n            g: (hexValue >> 16) & 255,\n            b: (hexValue >> 8) & 255,\n            a: hexValue & 255,\n            hex: '#' + hexCode.slice(0, 6).join('')\n        };\n    }\n    exports.getOptions = function getOptions(options) {\n        if (!options)\n            options = {};\n        if (!options.color)\n            options.color = {};\n        var margin = typeof options.margin === 'undefined' ||\n            options.margin === null ||\n            options.margin < 0 ? 4 : options.margin;\n        var width = options.width && options.width >= 21 ? options.width : undefined;\n        var scale = options.scale || 4;\n        return {\n            width: width,\n            scale: width ? 4 : scale,\n            margin: margin,\n            color: {\n                dark: hex2rgba(options.color.dark || '#000000ff'),\n                light: hex2rgba(options.color.light || '#ffffffff')\n            },\n            type: options.type,\n            rendererOpts: options.rendererOpts || {}\n        };\n    };\n    exports.getScale = function getScale(qrSize, opts) {\n        return opts.width && opts.width >= qrSize + opts.margin * 2\n            ? opts.width / (qrSize + opts.margin * 2)\n            : opts.scale;\n    };\n    exports.getImageWidth = function getImageWidth(qrSize, opts) {\n        var scale = exports.getScale(qrSize, opts);\n        return Math.floor((qrSize + opts.margin * 2) * scale);\n    };\n    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n        var size = qr.modules.size;\n        var data = qr.modules.data;\n        var scale = exports.getScale(size, opts);\n        var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n        var scaledMargin = opts.margin * scale;\n        var palette = [opts.color.light, opts.color.dark];\n        for (var i = 0; i < symbolSize; i++) {\n            for (var j = 0; j < symbolSize; j++) {\n                var posDst = (i * symbolSize + j) * 4;\n                var pxColor = opts.color.light;\n                if (i >= scaledMargin && j >= scaledMargin &&\n                    i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n                    var iSrc = Math.floor((i - scaledMargin) / scale);\n                    var jSrc = Math.floor((j - scaledMargin) / scale);\n                    pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n                }\n                imgData[posDst++] = pxColor.r;\n                imgData[posDst++] = pxColor.g;\n                imgData[posDst++] = pxColor.b;\n                imgData[posDst] = pxColor.a;\n            }\n        }\n    };\n});\nvar canvas = createCommonjsModule(function (module, exports) {\n    function clearCanvas(ctx, canvas, size) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (!canvas.style)\n            canvas.style = {};\n        canvas.height = size;\n        canvas.width = size;\n        canvas.style.height = size + 'px';\n        canvas.style.width = size + 'px';\n    }\n    function getCanvasElement() {\n        try {\n            return document.createElement('canvas');\n        }\n        catch (e) {\n            throw new Error('You need to specify a canvas element');\n        }\n    }\n    exports.render = function render(qrData, canvas, options) {\n        var opts = options;\n        var canvasEl = canvas;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!canvas) {\n            canvasEl = getCanvasElement();\n        }\n        opts = utils$1.getOptions(opts);\n        var size = utils$1.getImageWidth(qrData.modules.size, opts);\n        var ctx = canvasEl.getContext('2d');\n        var image = ctx.createImageData(size, size);\n        utils$1.qrToImageData(image.data, qrData, opts);\n        clearCanvas(ctx, canvasEl, size);\n        ctx.putImageData(image, 0, 0);\n        return canvasEl;\n    };\n    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n        var opts = options;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!opts)\n            opts = {};\n        var canvasEl = exports.render(qrData, canvas, opts);\n        var type = opts.type || 'image/png';\n        var rendererOpts = opts.rendererOpts || {};\n        return canvasEl.toDataURL(type, rendererOpts.quality);\n    };\n});\nfunction getColorAttrib(color, attrib) {\n    var alpha = color.a / 255;\n    var str = attrib + '=\"' + color.hex + '\"';\n    return alpha < 1\n        ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n        : str;\n}\nfunction svgCmd(cmd, x, y) {\n    var str = cmd + x;\n    if (typeof y !== 'undefined')\n        str += ' ' + y;\n    return str;\n}\nfunction qrToPath(data, size, margin) {\n    var path = '';\n    var moveBy = 0;\n    var newRow = false;\n    var lineLength = 0;\n    for (var i = 0; i < data.length; i++) {\n        var col = Math.floor(i % size);\n        var row = Math.floor(i / size);\n        if (!col && !newRow)\n            newRow = true;\n        if (data[i]) {\n            lineLength++;\n            if (!(i > 0 && col > 0 && data[i - 1])) {\n                path += newRow\n                    ? svgCmd('M', col + margin, 0.5 + row + margin)\n                    : svgCmd('m', moveBy, 0);\n                moveBy = 0;\n                newRow = false;\n            }\n            if (!(col + 1 < size && data[i + 1])) {\n                path += svgCmd('h', lineLength);\n                lineLength = 0;\n            }\n        }\n        else {\n            moveBy++;\n        }\n    }\n    return path;\n}\nvar render = function render(qrData, options, cb) {\n    var opts = utils$1.getOptions(options);\n    var size = qrData.modules.size;\n    var data = qrData.modules.data;\n    var qrcodesize = size + opts.margin * 2;\n    var bg = !opts.color.light.a\n        ? ''\n        : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n            ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n    var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n        ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n    var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n    var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n    var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n    if (typeof cb === 'function') {\n        cb(null, svgTag);\n    }\n    return svgTag;\n};\nvar svgTag = {\n    render: render\n};\nfunction renderCanvas(renderFunc, canvas, text, opts, cb) {\n    var args = [].slice.call(arguments, 1);\n    var argsNum = args.length;\n    var isLastArgCb = typeof args[argsNum - 1] === 'function';\n    if (!isLastArgCb && !canPromise()) {\n        throw new Error('Callback required as last argument');\n    }\n    if (isLastArgCb) {\n        if (argsNum < 2) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 2) {\n            cb = text;\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 3) {\n            if (canvas.getContext && typeof cb === 'undefined') {\n                cb = opts;\n                opts = undefined;\n            }\n            else {\n                cb = opts;\n                opts = text;\n                text = canvas;\n                canvas = undefined;\n            }\n        }\n    }\n    else {\n        if (argsNum < 1) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 1) {\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 2 && !canvas.getContext) {\n            opts = text;\n            text = canvas;\n            canvas = undefined;\n        }\n        return new Promise(function (resolve, reject) {\n            try {\n                var data = qrcode.create(text, opts);\n                resolve(renderFunc(data, canvas, opts));\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    try {\n        var data = qrcode.create(text, opts);\n        cb(null, renderFunc(data, canvas, opts));\n    }\n    catch (e) {\n        cb(e);\n    }\n}\nvar create$1 = qrcode.create;\nvar toCanvas = renderCanvas.bind(null, canvas.render);\nvar toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);\n// only svg for now.\nvar toString_1 = renderCanvas.bind(null, function (data, _, opts) {\n    return svgTag.render(data, opts);\n});\nvar browser = {\n    create: create$1,\n    toCanvas: toCanvas,\n    toDataURL: toDataURL,\n    toString: toString_1\n};\nvar amplifyTotpSetupCss = \".totp-setup{text-align:center;margin-bottom:30px}.totp-setup img{height:128px;width:128px}\";\nvar logger = new Logger('TOTP');\nvar AmplifyTOTPSetup = /** @class */ (function () {\n    function class_1(hostRef) {\n        registerInstance(this, hostRef);\n        this.inputProps = {\n            autoFocus: true,\n        };\n        /** Auth state change handler for this component */\n        this.handleAuthStateChange = dispatchAuthStateChangeEvent;\n        /** Used for header text in totp setup component */\n        this.headerText = Translations.TOTP_HEADER_TEXT;\n        /** Used for customizing the issuer string in the qr code image */\n        this.issuer = Translations.TOTP_ISSUER;\n        this.code = null;\n        this.setupMessage = null;\n        this.qrCodeInput = null;\n        this.loading = false;\n    }\n    class_1.prototype.componentWillLoad = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        /**\n                         * We didn't use `@Watch` here because it doesn't fire when we go from require-new-password to totp-setup.\n                         * That is because `Auth.completeNewPassword` only changes `user` in place and Watch doesn't detect changes\n                         * unless we make a clone.\n                         */\n                        this.removeHubListener = onAuthUIStateChange(function (authState) {\n                            if (authState === AuthState.TOTPSetup)\n                                _this.setup();\n                        });\n                        return [4 /*yield*/, this.setup()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.disconnectedCallback = function () {\n        this.removeHubListener && this.removeHubListener(); // stop listening to `onAuthUIStateChange`\n    };\n    class_1.prototype.buildOtpAuthPath = function (user, issuer, secretKey) {\n        return \"otpauth://totp/\" + issuer + \":\" + user.username + \"?secret=\" + secretKey + \"&issuer=\" + issuer;\n    };\n    class_1.prototype.onTOTPEvent = function (event, data, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('on totp event', event, data);\n                        if (!(event === SETUP_TOTP && data === SUCCESS)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, checkContact(user, this.handleAuthStateChange)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.handleTotpInputChange = function (event) {\n        this.setupMessage = null;\n        this.qrCodeInput = event.target.value;\n    };\n    class_1.prototype.generateQRCode = function (codeFromTotp) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        _a = this;\n                        return [4 /*yield*/, browser.toDataURL(codeFromTotp)];\n                    case 1:\n                        _a.qrCodeImageSource = _b.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _b.sent();\n                        dispatchToastHubEvent(error_1);\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.setup = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedIssuer, secretKey, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // ensure setup is only run once after totp setup is available\n                        if (!this.user || this.user.challengeName !== 'MFA_SETUP' || this.loading)\n                            return [2 /*return*/];\n                        this.setupMessage = null;\n                        encodedIssuer = encodeURI(I18n.get(this.issuer));\n                        if (!Auth || typeof Auth.setupTOTP !== 'function') {\n                            throw new Error(NO_AUTH_MODULE_FOUND);\n                        }\n                        this.loading = true;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4 /*yield*/, Auth.setupTOTP(this.user)];\n                    case 2:\n                        secretKey = _a.sent();\n                        logger.debug('secret key', secretKey);\n                        this.code = this.buildOtpAuthPath(this.user, encodedIssuer, secretKey);\n                        this.generateQRCode(this.code);\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_2 = _a.sent();\n                        dispatchToastHubEvent(error_2);\n                        logger.debug(I18n.get(Translations.TOTP_SETUP_FAILURE), error_2);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        this.loading = false;\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.verifyTotpToken = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var user, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (event) {\n                            event.preventDefault();\n                        }\n                        if (!this.qrCodeInput) {\n                            logger.debug('No TOTP Code provided');\n                            return [2 /*return*/];\n                        }\n                        user = this.user;\n                        if (!Auth ||\n                            typeof Auth.verifyTotpToken !== 'function' ||\n                            typeof Auth.setPreferredMFA !== 'function') {\n                            throw new Error(NO_AUTH_MODULE_FOUND);\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, Auth.verifyTotpToken(user, this.qrCodeInput)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, Auth.setPreferredMFA(user, MfaOption.TOTP)];\n                    case 3:\n                        _a.sent();\n                        this.setupMessage = I18n.get(Translations.TOTP_SUCCESS_MESSAGE);\n                        logger.debug(I18n.get(Translations.TOTP_SUCCESS_MESSAGE));\n                        return [4 /*yield*/, this.onTOTPEvent(SETUP_TOTP, SUCCESS, user)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        error_3 = _a.sent();\n                        this.setupMessage = I18n.get(Translations.TOTP_SETUP_FAILURE);\n                        logger.error(error_3);\n                        return [3 /*break*/, 6];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.render = function () {\n        var _this = this;\n        return (h(Host, null, h(\"amplify-form-section\", { headerText: I18n.get(this.headerText), submitButtonText: I18n.get(Translations.TOTP_SUBMIT_BUTTON_TEXT), handleSubmit: function (event) { return _this.verifyTotpToken(event); }, loading: this.loading }, h(\"div\", { class: \"totp-setup\" }, this.qrCodeImageSource && (h(\"img\", { src: this.qrCodeImageSource, alt: I18n.get(Translations.QR_CODE_ALT) })), h(\"amplify-form-field\", { label: I18n.get(Translations.TOTP_LABEL), inputProps: this.inputProps, fieldId: \"totpCode\", name: \"totpCode\", handleInputChange: function (event) { return _this.handleTotpInputChange(event); } })))));\n    };\n    return class_1;\n}());\nAmplifyTOTPSetup.style = amplifyTotpSetupCss;\nexport { AmplifyRadioButton as amplify_radio_button, AmplifyToast as amplify_toast, AmplifyTOTPSetup as amplify_totp_setup };\n"],"sourceRoot":""}